#!/usr/bin/env python3
"""
AI Interactive Terminal - Python Implementation
A PTY-based tool for interacting with terminal applications
"""

import sys
import os
import pty
import select
import termios
import struct
import fcntl
import json
import socket
import signal
import time
import argparse
from pathlib import Path
import tempfile

class Screen:
    """Simple terminal emulator screen buffer"""
    
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.cells = [[' ' for _ in range(cols)] for _ in range(rows)]
        self.cursor_row = 0
        self.cursor_col = 0
        
    def scroll_up(self):
        """Scroll screen up by one line"""
        self.cells.pop(0)
        self.cells.append([' ' for _ in range(self.cols)])
    
    def print_char(self, c):
        """Print a character at cursor position"""
        if self.cursor_row < self.rows and self.cursor_col < self.cols:
            self.cells[self.cursor_row][self.cursor_col] = c
            self.cursor_col += 1
            if self.cursor_col >= self.cols:
                self.cursor_col = 0
                self.cursor_row += 1
                if self.cursor_row >= self.rows:
                    self.scroll_up()
                    self.cursor_row = self.rows - 1
    
    def handle_control(self, byte):
        """Handle control characters"""
        if byte == ord('\n'):
            self.cursor_row += 1
            if self.cursor_row >= self.rows:
                self.scroll_up()
                self.cursor_row = self.rows - 1
            self.cursor_col = 0
        elif byte == ord('\r'):
            self.cursor_col = 0
        elif byte == ord('\t'):
            self.cursor_col = ((self.cursor_col // 8) + 1) * 8
            if self.cursor_col >= self.cols:
                self.cursor_col = self.cols - 1
        elif byte == 0x08:  # backspace
            if self.cursor_col > 0:
                self.cursor_col -= 1
    
    def handle_csi(self, params, action):
        """Handle CSI escape sequences"""
        if action in ('H', 'f'):  # Cursor position
            row = (params[0] if len(params) > 0 else 1) - 1
            col = (params[1] if len(params) > 1 else 1) - 1
            self.cursor_row = min(row, self.rows - 1)
            self.cursor_col = min(col, self.cols - 1)
        elif action == 'A':  # Cursor up
            n = max(params[0] if params else 1, 1)
            self.cursor_row = max(0, self.cursor_row - n)
        elif action == 'B':  # Cursor down
            n = max(params[0] if params else 1, 1)
            self.cursor_row = min(self.rows - 1, self.cursor_row + n)
        elif action == 'C':  # Cursor forward
            n = max(params[0] if params else 1, 1)
            self.cursor_col = min(self.cols - 1, self.cursor_col + n)
        elif action == 'D':  # Cursor back
            n = max(params[0] if params else 1, 1)
            self.cursor_col = max(0, self.cursor_col - n)
        elif action == 'J':  # Erase display
            mode = params[0] if params else 0
            if mode == 0:  # Clear from cursor to end
                for col in range(self.cursor_col, self.cols):
                    self.cells[self.cursor_row][col] = ' '
                for row in range(self.cursor_row + 1, self.rows):
                    for col in range(self.cols):
                        self.cells[row][col] = ' '
            elif mode == 2:  # Clear entire screen
                self.cells = [[' ' for _ in range(self.cols)] for _ in range(self.rows)]
                self.cursor_row = 0
                self.cursor_col = 0
        elif action == 'K':  # Erase line
            mode = params[0] if params else 0
            if mode == 0:  # Clear from cursor to end of line
                for col in range(self.cursor_col, self.cols):
                    self.cells[self.cursor_row][col] = ' '
            elif mode == 2:  # Clear entire line
                for col in range(self.cols):
                    self.cells[self.cursor_row][col] = ' '
    
    def process_output(self, data):
        """Process output data with basic escape sequence parsing"""
        i = 0
        while i < len(data):
            byte = data[i]
            
            # Handle escape sequences
            if byte == 0x1b and i + 1 < len(data):
                if data[i + 1] == ord('['):  # CSI
                    # Parse CSI sequence
                    i += 2
                    params = []
                    current_param = ''
                    
                    while i < len(data):
                        c = chr(data[i])
                        if c.isdigit():
                            current_param += c
                            i += 1
                        elif c == ';':
                            params.append(int(current_param) if current_param else 0)
                            current_param = ''
                            i += 1
                        elif c.isalpha():
                            if current_param:
                                params.append(int(current_param))
                            self.handle_csi(params, c)
                            i += 1
                            break
                        else:
                            i += 1
                            break
                    continue
                else:
                    # Skip other escape sequences
                    i += 2
                    continue
            
            # Handle control characters
            if byte < 0x20:
                self.handle_control(byte)
            elif byte < 0x7f:
                self.print_char(chr(byte))
            
            i += 1
    
    def render(self):
        """Render the screen as a string"""
        return '\n'.join(''.join(row) for row in self.cells)


class DaemonState:
    """State for the daemon process"""
    
    def __init__(self, master_fd, child_pid, socket_path, rows, cols, socket_was_auto_generated):
        self.master_fd = master_fd
        self.child_pid = child_pid
        self.socket_path = socket_path
        self.screen = Screen(rows, cols)
        self.exit_code = None
        self.should_shutdown = False
        self.socket_was_auto_generated = socket_was_auto_generated
        
    def check_child_status(self):
        """Check if child process has exited"""
        if self.exit_code is not None:
            return
        
        try:
            pid, status = os.waitpid(self.child_pid, os.WNOHANG)
            if pid == self.child_pid:
                if os.WIFEXITED(status):
                    self.exit_code = os.WEXITSTATUS(status)
                elif os.WIFSIGNALED(status):
                    self.exit_code = 128 + os.WTERMSIG(status)
        except ChildProcessError:
            pass
    
    def read_pty_output(self):
        """Read output from PTY and update screen"""
        try:
            data = os.read(self.master_fd, 4096)
            if data:
                self.screen.process_output(data)
        except (OSError, IOError):
            pass


def parse_terminal_size(size_str):
    """Parse terminal size string like '80x24'"""
    try:
        parts = size_str.split('x')
        if len(parts) != 2:
            raise ValueError(f"Invalid size format: {size_str}")
        cols = int(parts[0])
        rows = int(parts[1])
        if cols <= 0 or rows <= 0:
            raise ValueError(f"Invalid size: {size_str}")
        return cols, rows
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def auto_generate_socket_path():
    """Generate an auto socket path"""
    temp_dir = tempfile.mkdtemp(prefix="ainter-")
    return os.path.join(temp_dir, "sock")


def set_window_size(fd, rows, cols):
    """Set the window size for the PTY"""
    winsize = struct.pack('HHHH', rows, cols, 0, 0)
    fcntl.ioctl(fd, termios.TIOCSWINSZ, winsize)


def cmd_start(args):
    """Start command - launch a program in a PTY"""
    socket_was_auto_generated = args.socket is None
    socket_path = args.socket if args.socket else auto_generate_socket_path()
    
    cols, rows = parse_terminal_size(args.size)
    
    if args.no_daemon:
        # Run in foreground
        print(f"Socket: {socket_path}")
        print(f"Auto-generated: {socket_was_auto_generated}")
        run_daemon(socket_path, cols, rows, args.command, socket_was_auto_generated)
    else:
        # Daemonize (double fork)
        pid = os.fork()
        if pid > 0:
            # Parent - wait for intermediate child
            os.waitpid(pid, 0)
            print(f"Socket: {socket_path}")
            print(f"Auto-generated: {socket_was_auto_generated}")
            sys.stdout.flush()
            return
        
        # Intermediate child
        os.setsid()
        
        # Second fork
        pid = os.fork()
        if pid > 0:
            # Intermediate child prints PID and exits
            print(f"PID: {pid}")
            sys.stdout.flush()
            sys.exit(0)
        
        # Grandchild (daemon)
        # Close standard file descriptors properly
        os.close(0)
        os.close(1)
        os.close(2)
        
        # Open /dev/null for stdin/stdout/stderr
        devnull = os.open('/dev/null', os.O_RDWR)
        os.dup2(devnull, 0)
        os.dup2(devnull, 1)
        os.dup2(devnull, 2)
        if devnull > 2:
            os.close(devnull)
        
        # Run daemon
        run_daemon(socket_path, cols, rows, args.command, socket_was_auto_generated)


def run_daemon(socket_path, cols, rows, command, socket_was_auto_generated):
    """Run the daemon process"""
    # Create PTY
    master_fd, slave_fd = pty.openpty()
    
    # Set window size
    set_window_size(slave_fd, rows, cols)
    
    # Fork to create child process
    child_pid = os.fork()
    
    if child_pid == 0:
        # Child process
        os.close(master_fd)
        
        # Create new session
        os.setsid()
        
        # Set controlling terminal
        fcntl.ioctl(slave_fd, termios.TIOCSCTTY, 0)
        
        # Redirect stdio
        os.dup2(slave_fd, 0)
        os.dup2(slave_fd, 1)
        os.dup2(slave_fd, 2)
        
        if slave_fd > 2:
            os.close(slave_fd)
        
        # Execute command
        os.execvp(command[0], command)
        sys.exit(1)
    
    # Parent (daemon) process
    os.close(slave_fd)
    
    # Create state
    state = DaemonState(master_fd, child_pid, socket_path, rows, cols, socket_was_auto_generated)
    
    # Create Unix socket
    if os.path.exists(socket_path):
        os.unlink(socket_path)
    
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(socket_path)
    sock.listen(5)
    sock.setblocking(False)
    
    # Main daemon loop
    try:
        while not state.should_shutdown:
            # Check child status
            state.check_child_status()
            
            # Read PTY output
            state.read_pty_output()
            
            # Accept connections
            try:
                client_sock, _ = sock.accept()
                handle_client(client_sock, state)
            except BlockingIOError:
                pass
            
            time.sleep(0.05)
    finally:
        # Cleanup
        os.close(master_fd)
        sock.close()
        
        if socket_was_auto_generated:
            try:
                os.unlink(socket_path)
                os.rmdir(os.path.dirname(socket_path))
            except:
                pass


def handle_client(client_sock, state):
    """Handle a client connection"""
    debug_log = None
    try:
        # DEBUG: Open log file
        try:
            debug_log = open('/tmp/ainter_debug.log', 'a')
            debug_log.write(f"handle_client started\n")
            debug_log.flush()
        except:
            pass
        
        # Set socket timeout to prevent hanging
        client_sock.settimeout(5.0)
        
        # Read request
        data = b''
        while True:
            try:
                chunk = client_sock.recv(4096)
                if not chunk:
                    break
                data += chunk
                if b'\n' in data:
                    break
            except socket.timeout:
                if debug_log:
                    debug_log.write("Socket timeout while reading\n")
                    debug_log.flush()
                break
        
        if not data:
            if debug_log:
                debug_log.write("No data received\n")
                debug_log.flush()
            return
        
        if debug_log:
            debug_log.write(f"Received data: {data}\n")
            debug_log.flush()
        
        request = json.loads(data.decode('utf-8').strip())
        req_type = request.get('type')
        
        if debug_log:
            debug_log.write(f"Request type: {req_type}\n")
            debug_log.flush()
        
        # Handle request
        if req_type == 'OUTPUT':
            response = handle_output(state)
        elif req_type == 'INPUT':
            response = handle_input(request.get('data'), state)
        elif req_type == 'RUNNING':
            response = handle_running(state)
        elif req_type == 'STOP':
            response = handle_stop(state)
        elif req_type == 'WAIT':
            response = handle_wait(state)
        elif req_type == 'KILL':
            response = handle_kill(request.get('data'), state)
        elif req_type == 'RESIZE':
            response = handle_resize(request.get('data'), state)
        else:
            response = {'status': 'error', 'error': f'Unknown command: {req_type}'}
        
        # Send response
        if debug_log:
            debug_log.write(f"Sending response: {response}\n")
            debug_log.flush()
        
        response_json = json.dumps(response) + '\n'
        client_sock.sendall(response_json.encode('utf-8'))
        
        if debug_log:
            debug_log.write("Response sent successfully\n")
            debug_log.flush()
        
    except Exception as e:
        if debug_log:
            debug_log.write(f"Exception: {e}\n")
            debug_log.flush()
        error_response = json.dumps({'status': 'error', 'error': str(e)}) + '\n'
        try:
            client_sock.sendall(error_response.encode('utf-8'))
        except:
            pass
    finally:
        client_sock.close()
        if debug_log:
            debug_log.write("Client socket closed\n")
            debug_log.flush()
            debug_log.close()


def handle_output(state):
    """Handle OUTPUT request"""
    return {
        'status': 'ok',
        'data': {'screen': state.screen.render()}
    }


def handle_input(data, state):
    """Handle INPUT request"""
    if not data or 'data' not in data:
        return {'status': 'error', 'error': 'Missing data field'}
    
    input_str = data['data']
    try:
        os.write(state.master_fd, input_str.encode('utf-8'))
        return {'status': 'ok', 'data': {'message': 'Input sent'}}
    except Exception as e:
        return {'status': 'error', 'error': str(e)}


def handle_running(state):
    """Handle RUNNING request"""
    running = state.exit_code is None
    return {
        'status': 'ok',
        'data': {
            'running': running,
            'exit_code': state.exit_code
        }
    }


def handle_stop(state):
    """Handle STOP request"""
    if state.exit_code is None:
        try:
            os.kill(state.child_pid, signal.SIGTERM)
        except:
            pass
    
    state.should_shutdown = True
    return {'status': 'ok', 'data': {'message': 'Shutting down'}}


def handle_wait(state):
    """Handle WAIT request"""
    # Wait for child to exit
    timeout = 10
    start = time.time()
    
    while state.exit_code is None and (time.time() - start) < timeout:
        state.check_child_status()
        time.sleep(0.1)
    
    return {
        'status': 'ok',
        'data': {
            'exit_code': state.exit_code,
            'running': state.exit_code is None
        }
    }


def handle_kill(data, state):
    """Handle KILL request"""
    if not data or 'signal' not in data:
        sig = signal.SIGTERM
    else:
        sig_str = data['signal']
        try:
            if sig_str.isdigit():
                sig = int(sig_str)
                # Validate signal number range
                if sig < 1 or sig > 64:
                    return {'status': 'error', 'error': f'Invalid signal: {sig_str}'}
            else:
                sig_name = sig_str if sig_str.startswith('SIG') else f'SIG{sig_str}'
                try:
                    sig = getattr(signal, sig_name.upper())
                except AttributeError:
                    return {'status': 'error', 'error': f'Invalid signal: {sig_str}'}
        except (ValueError, TypeError):
            return {'status': 'error', 'error': f'Invalid signal: {sig_str}'}
    
    try:
        os.kill(state.child_pid, sig)
        return {'status': 'ok', 'data': {'message': f'Signal {sig} sent'}}
    except Exception as e:
        return {'status': 'error', 'error': str(e)}


def handle_resize(data, state):
    """Handle RESIZE request"""
    if not data or 'cols' not in data or 'rows' not in data:
        return {'status': 'error', 'error': 'Missing cols or rows field'}
    
    cols = data['cols']
    rows = data['rows']
    
    try:
        set_window_size(state.master_fd, rows, cols)
        
        # Resize screen buffer
        state.screen = Screen(rows, cols)
        
        return {'status': 'ok', 'data': {'message': f'Resized to {cols}x{rows}'}}
    except Exception as e:
        return {'status': 'error', 'error': str(e)}


def send_request(socket_path, request):
    """Send a request to the daemon"""
    sock = None
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(socket_path)
        
        # Set timeout AFTER connect for recv only
        sock.settimeout(5.0)
        
        request_json = json.dumps(request) + '\n'
        sock.sendall(request_json.encode('utf-8'))
        
        # Read response
        data = b''
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
            if b'\n' in data:
                break
        
        if not data:
            return {'status': 'error', 'error': 'No response'}
        
        return json.loads(data.decode('utf-8').strip())
    
    except FileNotFoundError:
        print(f"Error: Socket not found: {socket_path}", file=sys.stderr)
        sys.stderr.flush()
        sys.exit(1)
    except ConnectionRefusedError:
        print(f"Error: Connection refused: {socket_path}", file=sys.stderr)
        sys.stderr.flush()
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.stderr.flush()
        sys.exit(1)
    finally:
        if sock:
            try:
                sock.close()
            except:
                pass


def cmd_output(args):
    """Output command - get screen content"""
    request = {'type': 'OUTPUT'}
    response = send_request(args.socket, request)
    
    if response['status'] == 'error':
        print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
        sys.exit(1)
    
    print(response['data']['screen'])


def cmd_input(args):
    """Input command - send input to the program"""
    data = sys.stdin.read()
    request = {'type': 'INPUT', 'data': {'data': data}}
    response = send_request(args.socket, request)
    
    if response['status'] == 'error':
        print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
        sys.exit(1)


def cmd_running(args):
    """Running command - check if daemon is running"""
    request = {'type': 'RUNNING'}
    response = send_request(args.socket, request)
    
    if response['status'] == 'error':
        print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
        sys.exit(1)
    
    data = response['data']
    if not data['running']:
        sys.exit(1)


def cmd_stop(args):
    """Stop command - stop the daemon"""
    request = {'type': 'STOP'}
    response = send_request(args.socket, request)
    
    if response['status'] == 'error':
        print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
        sys.exit(1)


def cmd_wait(args):
    """Wait command - wait for program to exit"""
    request = {'type': 'WAIT'}
    response = send_request(args.socket, request)
    
    if response['status'] == 'error':
        print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
        sys.exit(1)
    
    data = response['data']
    if data['exit_code'] is not None:
        sys.exit(data['exit_code'])


def cmd_kill(args):
    """Kill command - send signal to child process"""
    request = {'type': 'KILL', 'data': {'signal': args.signal}}
    response = send_request(args.socket, request)
    
    if response['status'] == 'error':
        print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
        sys.stderr.flush()
        sys.exit(1)


def cmd_resize(args):
    """Resize command - resize the terminal"""
    cols, rows = parse_terminal_size(args.size)
    request = {'type': 'RESIZE', 'data': {'cols': cols, 'rows': rows}}
    response = send_request(args.socket, request)
    
    if response['status'] == 'error':
        print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description='AI Interactive Terminal Proxy')
    subparsers = parser.add_subparsers(dest='command', required=True)
    
    # Start command
    start_parser = subparsers.add_parser('start', help='Start a program')
    start_parser.add_argument('--socket', help='Socket path')
    start_parser.add_argument('--size', default='80x24', help='Terminal size (COLSxROWS)')
    start_parser.add_argument('--no-daemon', action='store_true', help='Run in foreground')
    start_parser.add_argument('command', nargs='+', help='Command to run')
    start_parser.set_defaults(func=cmd_start)
    
    # Output command
    output_parser = subparsers.add_parser('output', help='Get screen output')
    output_parser.add_argument('--socket', required=True, help='Socket path')
    output_parser.set_defaults(func=cmd_output)
    
    # Input command
    input_parser = subparsers.add_parser('input', help='Send input')
    input_parser.add_argument('--socket', required=True, help='Socket path')
    input_parser.set_defaults(func=cmd_input)
    
    # Running command
    running_parser = subparsers.add_parser('running', help='Check if running')
    running_parser.add_argument('--socket', required=True, help='Socket path')
    running_parser.set_defaults(func=cmd_running)
    
    # Stop command
    stop_parser = subparsers.add_parser('stop', help='Stop the daemon')
    stop_parser.add_argument('--socket', required=True, help='Socket path')
    stop_parser.set_defaults(func=cmd_stop)
    
    # Wait command
    wait_parser = subparsers.add_parser('wait', help='Wait for exit')
    wait_parser.add_argument('--socket', required=True, help='Socket path')
    wait_parser.set_defaults(func=cmd_wait)
    
    # Kill command
    kill_parser = subparsers.add_parser('kill', help='Send signal')
    kill_parser.add_argument('--socket', required=True, help='Socket path')
    kill_parser.add_argument('--signal', default='TERM', help='Signal to send')
    kill_parser.set_defaults(func=cmd_kill)
    
    # Resize command
    resize_parser = subparsers.add_parser('resize', help='Resize terminal')
    resize_parser.add_argument('--socket', required=True, help='Socket path')
    resize_parser.add_argument('--size', required=True, help='New size (COLSxROWS)')
    resize_parser.set_defaults(func=cmd_resize)
    
    args = parser.parse_args()
    
    # Handle special parsing for start command with --
    if args.command == 'start':
        # Find -- separator
        argv = sys.argv[1:]
        if '--' in argv:
            idx = argv.index('--')
            args.command = argv[idx + 1:]
        
    args.func(args)


if __name__ == '__main__':
    main()
